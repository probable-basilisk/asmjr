use crate::compression::compress_bytes;
use crate::ops::Op;
use std::vec::Vec;

use prost::Message;

// this is generated by prost
pub mod cart {
    include!(concat!(env!("OUT_DIR"), "/ecjr.cart.rs"));
}

// 4 bytes for (opcode, rd, rs1, rs2), 8 bytes for double immediate
const OPREGSIZE: usize = 4;
const OPIMMSIZE: usize = 8;
// 3 * u32
const SIZESIZE: usize = 12;

// The program serialization format is:
// [4 bytes: LE u32 of opcount]
// [4 bytes: LE u32 offset of op data in buffer]
// [4 bytes: LE u32 offset of immediates in buffer]
// [data]
pub fn serialize_ops(oplist: &[Op]) -> Vec<u8> {
    let reg_offset: u32 = SIZESIZE as u32;
    let mut imm_offset: u32 = (SIZESIZE + oplist.len() * OPREGSIZE) as u32;
    if imm_offset % (OPIMMSIZE as u32) != 0 {
        // Align immediate data to its data size (double = 8 bytes)
        // (might matter on some platforms where unaligned memory access
        //  has a significant performance penalty [ARM mac?])
        let pad = (OPIMMSIZE as u32) - (imm_offset % (OPIMMSIZE as u32));
        imm_offset += pad;
    }
    let datasize: usize = (imm_offset as usize) + OPIMMSIZE * oplist.len();
    let mut data: Vec<u8> = Vec::with_capacity(datasize);

    let opcount_bytes = (oplist.len() as u32).to_le_bytes();
    data.extend_from_slice(&opcount_bytes);

    let reg_offset_bytes = reg_offset.to_le_bytes();
    data.extend_from_slice(&reg_offset_bytes);

    let imm_offset_bytes = imm_offset.to_le_bytes();
    data.extend_from_slice(&imm_offset_bytes);

    for op in oplist.iter() {
        data.push(op.op.opcode);
        data.push(op.op.rd);
        data.push(op.op.rs1);
        data.push(op.op.rs2);
    }

    // fill the padding/alignment gap with zeros
    data.resize(imm_offset as usize, 0);

    for op in oplist.iter() {
        data.extend_from_slice(&op.imm.to_le_bytes());
    }

    data
}

pub fn pack_cartridge(
    metadata: Option<String>,
    videorom: Option<Vec<u8>>,
    program: &[Op],
    compress: bool,
) -> Vec<u8> {
    let metadata = metadata.unwrap_or_else(|| "{}".to_string());
    let videorom = videorom.unwrap_or_default();
    let cartridge_body = cart::Cartridge {
        metadata,
        videorom,
        program: serialize_ops(program),
    };

    let mut serialized_body = Vec::with_capacity(cartridge_body.encoded_len());
    // Unwrap is safe, since we have reserved sufficient capacity in the vector.
    cartridge_body.encode(&mut serialized_body).unwrap();
    let uncompressed_size = serialized_body.len() as u32;
    let (compressed_size, final_body) = if compress {
        let original_size = serialized_body.len();
        let compressed = compress_bytes(&serialized_body);
        println!("Compressed {} -> {}", original_size, compressed.len());
        (compressed.len() as u32, compressed)
    } else {
        (0u32, serialized_body)
    };

    let mut final_data: Vec<u8> = Vec::with_capacity(16 + final_body.len());
    final_data.extend_from_slice("ECJRV005".as_bytes());
    final_data.extend_from_slice(&uncompressed_size.to_le_bytes());
    final_data.extend_from_slice(&compressed_size.to_le_bytes());
    final_data.extend(final_body);

    final_data
}
